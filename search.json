[{"categories":null,"content":"go docker和nginx VSCode操作Docker  需要在VSCode中安装相关的插件，包括Docker、Remote-Containers和Remote-SSH； 在dockerhub上选择需要的镜像pull到本地，右击需要运行的的image选择“start”； 等待image右侧的图标变成绿色的运行标志后，右击已经运行的containers，点击“attach visual studio code\"即可跳出docker下的vscode窗口;  新建完成docker下的vscode窗口后，也可以在菜单栏的“文件”-\u003e“打开”重新选择需要的文件夹。（remote-containers和remote-ssh共用一套操作窗口）\ndocker常见命令   docker由镜像创建容器golang/ubuntu：docker run -it \u003cimage:version\u003e\n 可以在命令中加入–rm命令在退出后删除容器 可以在命令中加入-p命令来映射端口    docker运行创建的镜像：\n docker ps -a 查看所有存在的镜像，获得目标容器id docker start \u003ccontainer-id\u003e  打开目标容器 docker attach \u003ccontainer-id\u003e 连接进入容器    docker提交容器为镜像：\n1  docker commit -a \u003cauthor-id\u003e -m \u003ccomment\u003e \u003ccontainer-id\u003e \u003cimage:version\u003e     docker其它命令：\n docker images 显示所有镜像 docker rm \u003ccontainer-id\u003e 删除对应id容器 docker rmi \u003cimage-id\u003e 删除image-id镜像（删除前保证不存在对应容器） docker kill \u003ccontainer-id\u003e 在容器命令行外结束容器 docker diff \u003ccontainer-id\u003e 可以用于查看容器相对于容器的修改，输出结果中A表示新建，C表示修改，D表示删除。 docker history \u003cimage-id\u003e 查看镜像历史 docker build -t \u003cimage-id:version\u003e \u003cpath\u003e 使用指定路径下的dockerfile文件构建镜像，指定目录下的文件会一起打包交给docker构建引擎 docker stats 查看容器消耗系统资源 docker volume ls 查看所有存在的volume docker volume prune 清除所有不使用的volume    Dockerfile定制镜像 参考资料：docker从入门到实践\ndocker commit命令一般不用于镜像定制，通常会使用dockerfile文件制作需要的镜像。由于容器内部的每次操作都会被记录下来，因而会有大量的无关文件被添加到镜像中。\n 因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。\n镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。\n分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。\n– https://yeasy.gitbook.io/docker_practice/basic_concept/image\n Dockerfile 是一个文本文件，其内包含了一条条的指令，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建：参考dockerfile常用命令\n  FROM命令用于指定基础镜像\n  RUN命令用于运行shell，一次RUN命令对应一层\n  COPY命令从上下文复制文件或者目录到容器指定路径(复制文件夹时建议使用如COPY . /形式，见Docker COPY 复制文件夹的诡异行为)\n  CMD用于在docker build阶段运行程序，仅文件中最后一条命令生效\n  docker-compose\n1 2 3 4 5 6  version:\"3\"services:golang:build:.ubuntu:image:\"ubuntu:latest\"    docker运行的开销\n模拟负载均衡   参考资料：docker使用nginx模拟负载均衡\n 在本机上安装docker和nginx brew install nginx 在docker中下载nginx镜像并运行docker run --rm -it nginx -p 81/82:80新建nginx容器 进入nginx容器中，分别使用“web01”和“web02”代替掉/usr/share/nginx/html/index.html的内容 在/usr/local/etc/nginx/nginx.conf下修改server部分内容如下：  1 2 3 4 5 6 7 8 9  upstream myservers { server 127.0.0.1:81; server 127.0.0.1:82; } server { location / { proxy_pass http://myservers; } }\t  在浏览器下访问nginx页面或者使用curl命令请求nginx即可发现请求被分给docker容器内的nginx    正向代理和反向代理\n  docker查看容器ip\n  curl命令构造http请求\n  nginx监听端口、html文件位置等配置文件在/usr/local/etc/nginx/nginx.conf\n  mac下安装nginx mac下nginx常用命令：\n nginx 启动nginx nginx -s reload 重新启动 nginx -s stop 停止nginx运行    ","description":"","tags":null,"title":"docker模拟负载均衡","uri":"/it/docker%E6%A8%A1%E6%8B%9F%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":null,"content":"GEN基于GORM实现，是能兼容GORM高效查询架构和开发效率和业务安全性的最新工具。GEN在指定数据库中表名后，可以一键自动映射为对应结构体代码。这里尝试使用GEN来根据数据库表信息来自动生成golang struct。\n 首先在命令行中运行go get -u gorm.io/gen，并使用import gorm.io/gen引入gen包； 接着编写并运行如下示例代码：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  import ( \"gorm.io/driver/mysql\" \"gorm.io/gen\" \"gorm.io/gorm\" ) func TestGen() { g := gen.NewGenerator(gen.Config{OutPath: \"./model\"}) // OutPath内参数用于指定生成struct文件位置  dbConnStr := \"root:Aa@123456@tcp(127.0.0.1:3306)/test?charset=utf8mb4\u0026parseTime=True\u0026loc=\" + \"Local\u0026readTimeout=2000ms\u0026allowNativePasswords=true\" writeDb, _ := gorm.Open(mysql.Open(dbConnStr)) // 获得一个用于操作数据库的gorm对象 \tg.UseDB(writeDb) g.ApplyBasic(g.GenerateModel(\"admin_resource_group\")) // 对照admin_resource_group生成对应的golang struct \tg.ApplyBasic(g.GenerateModelAs(\"admin_resource_info\", \"ResourceInfo\")) // 对照admin_resource_group生成对应的结构体名为“ResourceInfo”的golang struct \tg.ApplyBasic(g.GenerateModelAs(\"admin_scope_config\", \"ScopeConfig\", gen.FieldIgnore(\"id\"))) // 对照admin_resource_group生成对应的结构体名为“ResourceInfo”的golang struct，并忽略其中的“id”项 \tg.Execute() }   生成文件如下图：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // Code generated by gorm.io/gen. DO NOT EDIT. // Code generated by gorm.io/gen. DO NOT EDIT. // Code generated by gorm.io/gen. DO NOT EDIT. package model const TableNameRoom = \"room\" // room type Room struct { ID int32 `json:\"id\" gorm:\"column:id\"` NameZH string `json:\"NameZH\" gorm:\"column:NameZH\"` TagType int32 `json:\"TagType\" gorm:\"column:TagType\"` } // TableName . func (*Room) TableName() string { return TableNameRoom }   ","description":"","tags":null,"title":"GEN包自动生成数据库表对应结构体","uri":"/it/gen%E5%8C%85%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E5%AF%B9%E5%BA%94%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":null,"content":"引用：mermaid语法  markdown flow流程图示例\nmermaid 通过 mermaid 可以实现以纯文本的方式绘制流程图，序列图，甘特图等。\nmermaid绘制流程图示例：\ngraph LR; a(a)--\u003eb[b] b--\u003ec{c} b--\u003ed((d)) b==\u003ee(e) d-.-\u003ef(f) f-.-\u003e|text|g(g) g==\u003e|\"t|e|x|t\"|h(h) 其中主要语法包括：\n graph TB/TD/BT/RL/LR:指定流程图前进方法。如：  TB/TD：top bottom BT：bottom top RL：right left   a(A)|[A]|{A}|((A)): 声明一个显示文本为A的流程框a。 a--\u003eb|a==\u003eb|a-.-\u003eb|: 声明一个由流程框a到b的箭头。 a==\u003e|text|b: 声明一个包含文本text的箭头，一般作为条件判断箭头使用。  flow start_node=\u003estart: 开始框 inputoutput_node=\u003einputoutput: 输入输出框 operation_node=\u003eoperation: 操作框 condition_node=\u003econdition: 条件判断框 end_node=\u003eend: 结束框 start_node(right)-\u003einputoutput_node-\u003eoperation_node operation_node(right)-\u003econdition_node condition_node(no)-\u003einputoutput_node condition_node(yes, bottom)-\u003eend_node  start_node=\u003estart: 开始框: 声明一个开始流程框start_node，内容为“开始框”。流程框有以下几种。  start: 开始框 inputoutput: 输入输出框 operation: 操作框 condition: 条件判断框 end: 结束框 subroutine: 子流程框   condition_node(yes, bottom)-\u003eend_node: 声明一个从condition_node指向end_node的箭头，yes为条件判断框特有的条件分支，bottom|top|left|right为箭头指向的方向。-\u003e可以在一个语句中多次使用。  ","description":"","tags":null,"title":"markdown绘制流程图","uri":"/it/markdown%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE/"},{"categories":null,"content":"由于线上环境与本地环境差别很大，因此通常我们开发的时候会首先在IDE上编写并调试代码，接着通过git将代码上传至远程仓库，最后在开发机下拉取提交的代码以尝试在一个更为接近线上环境的条件下测试代码。这里的操作相对烦琐，以往也有一些关于使用GoLand在本地与远程环境间同步代码的文档如golang自动同步代码，但在尝试过程中仍然容易遇到各种各样的问题如.git文件夹和新建及删除文件无法同步等。为了更好地提高开发效率，本文在这里会简单介绍一种新的在线编辑代码的方式。\nVSCode下载与使用 VSCode是一个微软推出的轻量级代码编辑器，它完全免费且开源，并支持几乎所有主流编程语言的开发。VSCode也支持Win、Mac以及Linux平台，打开VSCode官网，即可找到对应平台的VSCode下载链接。下载并安装完成后打开VSCode，可以看到它的界面如下图所示：\n界面右侧会有一些VSCode入门知识和使用简介，最左侧的是插件栏和设置入口。首先需要安装Go语言开发对应的插件。如下图所示：\n确保本地已安装Go的情况下，即可使用control+~快捷键方式调出终端。在VSCode中编写并完成代码后使用go run .命令来查看运行结果。在保持VSCode文档焦点在需要运行的源代码文件上时，也可以直接点击运行按钮来执行或者调试程序。\nVSCode远程连接与运行 为了在VSCode上查看并运行远程文件，首先需要安装Remote - SSH插件。\n安装完成后插件栏上会出现用于操作远程登录的插件图标，点开图标后找到SSH TARGET右侧的加号，输入ssh登录命令并输入密码，选择想要查看的项目文件夹，即可远程操作项目。\n由于VSCode操作文件夹时都需要密码，这里建议提前配置好开发机ssh登录密钥。首先在本机使用ssh-keygen命令生成密钥对，运行完成后当前用户目录下会生成一个.ssh文件夹，其中包含私钥文件id_rsa和公钥文件id_rsa.pub。接着将公钥复制到开发机的~/ .ssh/authorized_key文件中并修改权限。之后重新登录开发机，如果不需要输入密码即为登录成功。\n配置好上述步骤后即可编写并调试项目。由于VSCode直接操作开发机上的项目文件，当网络较差时会出现明显的延迟现象，因此建议在网络条件较好的情况下使用。在按照VSCode提示安装其它插件后也可以直接在开发机上进行程序调试操作。\n","description":"","tags":null,"title":"Visual Studio Code远程调试","uri":"/it/vscode%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"},{"categories":null,"content":"  vscode 取消 unused 提示\n  使用ctrl+shift+p快捷键打开vscode设置界面\n  在打开的命令行中输入\"setting\"打开setting.json文件\n  在文件最后加入：\n1 2 3  \"go.lintFlags\": [ \"--disable=U1000\" ]       ","description":"","tags":null,"title":"VSCode取消unused提示","uri":"/it/vscode%E5%8F%96%E6%B6%88unused%E6%8F%90%E7%A4%BA/"},{"categories":null,"content":"这是去年准备秋招的时候整理的一些Java面试常见知识点，整体内容由Java工程师精选面经合集和JavaGuide两个地方的常见知识点组织起来。各个章节里补充了一些面试时遇到的问题。因为文章是由Word转的markdown，部分章节里格式可能有问题。嗯就这样。\nJava基础 JDK和JRE区别  JDK： Java Development Kit，开发工具包。提供了编译运行 Java 程序的各种工具，包括编译器、JRE 及常用类库，是 JAVA 核心。 JRE： Java Runtime Environment，运行时环境，运行 Java 程序的必要环境，包括JVM、核心类库、核心配置工具。  即JRE用于运行Java程序，JDK用于开发Java程序，JDK包含JRE。\nJAVA基本数据类型及其大小 Java中基本数据类型包括字符类型，布尔类型和数值类型\n 字符型：char 布尔型：boolean 数值型：包括byte（1字节），short（2字节），int（4字节），long（8字节），float（4字节），double（8字节）。其中又可以细分为整型和浮点型  Java基本数据类型总结\nJava自动装箱/拆箱  自动装箱：将基本数据类型包装为一个包装类对象，例如向一个泛型为 Integer的集合添加 int 元素。 自动拆箱：将一个包装类对象转换为一个基本数据类型，例如将一个包装类对象赋值给一个基本数据类型的变量。  Java按值调用和引用调用 按值调用指方法接收调用者提供的值，按引用调用指方法接收调用者提供的变量地址。\nJava中传递基本数据类型和引用数据类型均为按值调用。因此传递引用数据类型时可以改变引用指向的对象内容，但不能改变引用指向。\nString类不能被继承原因 String类不可以被继承，String类的声明有包含有final\nString，Stringbuffer，StringBuilder区别。  String字符内容不可变，但Stringbuffer和StringBuilder里保存字符内容可变 StringBuilder线程不安全，Stringbuffer线程安全  字符串拼接方式 关于 Java字符串拼接的几种方式以及性能比较\n 直接用 + ，底层用 StringBuilder 实现。如果在循环中使用 +拼接，相当于不断创建新的 StringBuilder 对象再转换成 String 对象，效率差。 使用 String 的 concat 方法，该方法中使用 Arrays.copyOf 创建一个新的字符数组buf 并将当前字符串value 数组的值拷贝到 buf 中，buf 长度 = 当前字符串长度 +拼接字符串长度。之后调用 getChars 方法使用 System.arraycopy将拼接字符串的值也拷贝到 buf 数组，最后用 buf 作为构造参数 new 一个新的String 对象返回。效率稍高于直接使用 +。 使用 StringBuilder 或 StringBuffer，两者的 append 方法都继承自AbstractStringBuilder，该方法首先使用 Arrays.copyOf确定新的字符数组容量，再调用 getChars 方法使用 System.arraycopy将新的值追加到数组中。StringBuilder 是 JDK5引入的，效率高但线程不安全。StringBuffer 使用 synchronized 保证线程安全。  此外，字符串类型使用字面量时只创建一个常量池中的常量，使用 new时如果常量池中没有该值就会在常量池中新创建，再在堆中创建一个对象引用常量池中常量。\nString a=“ab” 与String a = new String(“ab”);的区别\nArrayList和LinkedList区别。  ArrayList是基于动态数组的实现，而LinkedList是基于链表的实现 随机访问set和get的效率，ArrayList要高于LinkedList 添加add和删除remove的效率，只能根据具体元素的位置确定谁快 两者都是线程不安全的  CopyOnWriteArrayList原理 Java并发编程：并发容器之CopyOnWriteArrayList（转载）\nCopyOnWrite容器即定时复制的容器。即向容器中添加元素时，不直接往当前容器添加，而是先复制一份容器，再向新容器中添加元素。添加完元素后，再将原容器的引用指向新的容器。此外，写的过程中会对容器使用ReentrantLock加锁。这样可以做到并发读取。\nCopyOnWrite容器适合读多写少的场合，单个添加元素时效率极低。\nCopyOnWrite容器 volatile （txc待补充部分）\nArrays.sort()实现 Java提供的排序算法是怎么实现的\n双轴快排原理解析\n类的实例化顺序和类的数据执行顺序  类的实例化顺序：加载、连接、初始化、实例化 类数据的执行顺序：   父类的静态变量，静态代码块（先声明的先执行 子类的静态变量，静态代码块（同上 父类的变量和代码块 父类的构造函数 子类的变量和代码块 子类的构造函数  总结：静态数据执行优先级最高；父类执行优先于子类，代码块优先于构造函数，先声明的优先于后声明的。\nMap种类及内部实现 Java中Map类包括HashMap/HashTable/LinkedHashMap/TreeMap\n HashMap HashTable，相对于HashMap，该数据结构线程安全。 LinkedHashMap，该数据结构能保证插入数据的有序性 TreeMap，能够按照SortMap接口对记录进行排序。基于红黑树实现，不同于HashMap，TreeMap依靠Comparable或 Comparator进行去重。 CurrentHashMap，jdk1.8前采用分段锁（代价高），之后采用CAS实现  HashMap内部原理：\n JDK1.8以前：数组加链表，hashCode后经扰动函数处理后得hash值，hash值与(n-1)相与得到存放地址。若存放地址有元素，且key相同则直接覆盖。否则用拉链法加在后面。 JDK1.8以后：如果某key的拉链长度过长（大于8），则会将拉链链表转化为红黑树。 HashMap初始大小为16。  Java中的HashSet内部工作原理 HashSet是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap的相关方法来完成。当往set里添加元素时，其值默认为PRESENT。\n此外，如果遇到添加重复值HashMap会用新值替换旧值，而HashSet不会。也就是说HashMap的旧值会被覆盖（使用put方法添加会返回旧值），而HashSet的旧值不会被覆盖（使用add添加会返回false）。\nHashMap的实现原理\nHashMap和HashSet添加重复值区别的源码分析\n抽象和接口类区别  抽象方法比接口速度快。 编写代码时尽量选用接口，抽象类仅当需要提供共性功能时使用。  类之间的关系 继承、实现、依赖、关联、聚合、组合的联系与区别\n继承、实现、依赖、关联、聚合、组合的定义与区别，这其中关系依据类间联系强弱可能存在争议：\n 继承：指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能。在Java中使用extends明确标明。 实现：指的是一个class类实现interface接口（可以是多个）的功能。在Java中此类关系通过关键字implements明确标识，在设计时一般没有争议性。 依赖：类A使用到了另一个类B。表现在代码层面，为类B作为参数被类A在某method方法中使用。 关联：体现的是两个类、或者类与接口之间语义级别的一种强依赖关系，一般是长期性的，而且双方的关系一般是平等的、关联可以是单向、双向的；表现在代码层面，为被关联类B以类属性的形式出现在关联类A中。 聚合：聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系。此时整体与部分之间是可分离的，区别与组合关系，各相关类可以具有各自的生命周期。表现在代码层面，和关联关系是一致的，只能从语义级别来区分； 组合：聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系。此时整体与部分之间是不可分离的，区别与聚合关系，整体的生命周期结束也就意味着部分的生命周期结束。表现在代码层面，和关联关系是一致的，只能从语义级别来区分；  相对于前两种关系，后四种关系相对难以区分。但总的来说，后几种关系所表现的强弱程度依次为：组合\u003e聚合\u003e关联\u003e依赖。\n示例：\n 依赖：(person) -\u003e(use) (computer) 关联：(you) -\u003e(friend) (me) 聚合：(family) -\u003e (child) 组合：(person)-\u003e(brain)  IO模型分类，nio/bio模型 深入理解java I/O模型（关于同步异步I/O）\n同步I/O：每个请求必须逐个地被处理，一个请求的处理会导致整个流程的暂时等待。\n异步I/O：多个请求可以并发地执行，一个请求或者任务的执行不会导致整个流程的暂时等待。\n阻塞I/O：某个请求发出后，由于该请求操作需要的条件不满足，请求操作一直阻塞，不会返回，直到条件满足。\n非阻塞I/O：请求发出后，若该请求需要的条件不满足，则立即返回一个标志信息告知条件不满足，而不会一直等待。一般需要通过循环判断请求条件是否满足来获取请求结果。\n同步和异步主要针对多任务情况，阻塞和非阻塞针对单任务情况。\nIO模型包括阻塞型IO、非阻塞型IO、多路复用型IO，信号驱动型IO、异步IO。\nBIO：使用BIO通信模型的服务端，通过一个Acceptor线程监听客户端。监听到连接请求后为每一个客户端创建一个新的线程链路处理，处理完成通过输出流回应客户端，线程消耗。BIO是典型一对一答模型。\nNIO核心组件：Channels、Buffers、Selectors 。\n Buffer本质是一块内存，连接发送线程和channel。有三属性包括位置、容量和限制。 Channel连接buffer，从Buffer中读写数据。 Selector非阻塞，用于实现一个线程管理多个channel，只要将channel注册到selector中即可，可以调用select()获取已经准备好的channel。  NIO工作流程：reactor通过select监控连接事件，收到事件后通过dispatch分发。连接事件交给acceptor处理，其它事件会调用相应的handler处理。\n区别与BIO，NIO面向缓冲区，而BIO面向流\nNIO模型相关API介绍\n BIO：同步阻塞 NIO：同步非阻塞 AIO：异步非阻塞，是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里。当后台处理完成，操作系统会通知相应的handler进行后续的操作。Handler中会读取、解码、计算、编码、最后返回处理结果。  高性能IO之reactor模式\nRector核心组件：\n Reactor：负责响应事件，将事件分发绑定了该事件的Handler处理 Handler：事件处理器，绑定了某类事件，负责执行对应事件的任务对事件进行处理 Acceptor：Handler的一种，绑定了 connect事件，当客户端发起connect请求时，Reactor会将accept事件分发给Acceptor处理。  Reactor多线程模型：\n改进：\n 将handler的运行通过线程池进行，使用多线程进行业务处理。 将reactor分为mainReactor及subReactor，mainReactor仍然负责监听连接，由subReactor负责建立连接和读写数据。  反射原理，反射创建类实例的方式 在运行状态中，对于任意一个类都能知道它的所有属性和方法，对于任意一个对象都能调用它的任意方法和属性，这种动态获取信息及调用对象方法的功能称为反射。缺点是破坏了封装性以及泛型约束。\n反射主要是通过java.lang.Class类来指向一个类型信息，通过Class对象来获取类里所有的内部信息。框架中大量使用反射。\n反射的基本原理\nObject类的方法 Equals/hashCode/toString/clone/finalize/getClass/(wait/notify/notifyAll)\nJava Class类 Class类中保存了对象所属类的相关结构和信息。可以使用下面方法获取Class对象\n 类名.Class 对象.getClass() Class.forName(类全名)  可以使用Class对象的newInstance()来实例化一个对应类的对象。初始化方法为调用无参的初始化方法。\n内部类的分类 Java内部类详解\n  成员内部类：最普通的内部类，定义位于一个类的内部，类似于类的一个成员。成员内部类可以访问外部类的所有成员属性和成员方法。如果要创建成员内部类的对象，必须首先创建一个外部类对象。然后通过外部类对象来new内部类对象。例：\nOutter outter = new Outter(); Outter.Inner inner = outter.new Inner();\n  局部内部类：定义在方法或作用域里的类，只能在方法或者作用域内访问。\n  匿名内部类：定义在方法参数内的类\n  静态内部类：属于外部类，只加载一次。作用域仅在包内，可通过外部类名.内部类名直接访问，类内只能访问外部类所有静态属性和方法，但不依赖于外部类。\n  Class.forName和ClassLoader区别 。 Class.forName和ClassLoader区别\n Class.forName除了将类的.class文件加载到jvm中之外，还会对类进行解释，可以通过参数控制是否执行类中的static块。 classloader只将.class文件加载到jvm中，不会执行static中的内容，只有在newInstance才会去执行static块。  ClassLoader作用 Java ClassLoader详解\n Class字节码：本质就是一个字节数组 byte[]，可以来自于磁盘文件*.class，也可以是 jar 包里的 *.class，也可以来自远程服务器提供的字节流。 延迟加载：程序在运行的过程中会逐渐遇到很多不认识的新类，这时候就会调用ClassLoader 来加载这些类。加载完成后就会将 Class 对象存在 ClassLoader里面，下次就不需要重新加载了。 ClassLoader传递性：遇到未知类时，使用调用者 Class 对象的 ClassLoader来加载当前未知的类。 三个重要ClassLoader (BootstrapClassLoader：$JAVA_HOME/lib/rt.jar、ExtensionClassLoader：$JAVA_HOME/lib/ext/*.jar、AppClassLoader：编写代码及第三方jar包) （位于不同 ClassLoader 中名称一样的类实际上是不同的类）  加载类的方式  启动应用时由JVM初始化加载 通过Class.forName()方法加载 通过ClassLoader.loadClass()加载  动态代理实现方式及其优缺点 若代理类在程序运行前就已经存在，那么这种代理方式被称为静态代理。静态代理可以通过聚合来实现，让代理类持有一个委托类的引用即可。\n代理类在程序运行时创建的代理方式被称为动态代理。使用动态代理时，我们需要定义一个位于代理类与委托类之间的中介类，这个中介类被要求实现InvocationHandler接口。当调用代理类对象的方法时，这个调用会转到invoke方法中。动态代理关系由两组静态代理关系组成。\n其它：代理模式：代理模式特点是代理类和实际业务类实现同一个接口（或继承同一父类），代理对象持有一个实际对象的引用，外部调用时操作的是代理对象，而在代理对象的内部实现中又会去调用实际对象的操作。\nJava动态代理\nJava动态代理的两种实现方式\n jdk动态代理实现：由内部反射机制实现。通过让target类和代理类实现同一接口，代理类持有target对象，来达到方法拦截的作用。使用InvocationHandler接口。 cglib动态代理实现：底层使用ASM在内存中动态的生成被代理类的子类，使用CGLIB即使代理类没有实现任何接口也可以实现动态代理功能。  两者区别：\n jdk动态代理是由java内部的反射机制来实现的，cglib动态代理底层则是借助asm来实现的。 反射机制在生成类的过程中比较高效，而asm在生成类之后的相关执行过程中比较高效。 jdk动态代理的应用前提，必须是目标类基于统一的接口。Cglib动态代理不需要。  Cglib原理和特点  CGlib原理：动态生成一个要代理类的子类，子类重写要代理的类的所有不是final的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，织入横切逻辑。 CGlib底层：使用字节码处理框架ASM，来转换字节码并生成新的类。不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。 CGlib缺点：对于final方法，无法进行代理。  CGlib介绍与原理\nfinal用途  修饰类：表明这个类不能被继承。注意final类中的所有成员方法都会被隐式地指定为final方法。尽量不要将类设计为final类。 修饰方法：方法在子类中不会被覆盖。类的private方法会隐式地被指定为final方法。 修饰变量：对于final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。  当final修饰变量时，static变量必须在声明时初始化，普通成员变量可以在构造方法中初始化。\nFinal关键字深入解析\n三种单例模式实现。 单例模式的七种写法\n饿汉模式\n懒汉模式（双重检查+volatile）（一检空为减少访问同步块提高效率，二检为是否已执行到，volatile防止指令重排序让未初始化对象被调用）\n静态内部类：静态类不用先创建外部类。使用不需要外部类实例；而非静态就必须先实例化\n1 2 3 4 5 6 7 8 9  public class Singleton { private Singleton(){} public static Singleton getInstance(){ return SingletonHolder.sInstance; } private static class SingletonHolder { private static final Singleton sInstance = new Singleton(); } }   枚举类：枚举类型是线程安全的，并且只会装载一次。可以使用该特性来实现模式（推荐）\n1 2 3 4 5 6 7 8 9 10 11 12 13  private enum Singleton{ INSTANCE; private final SingletonObject7 instance; Singleton(){ instance = new SingletonObject7(); } private SingletonObject7 getInstance(){ return instance; } } public static SingletonObject7 getInstance(){ return Singleton.INSTANCE.getInstance(); }   如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。 请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。   深拷贝和浅拷贝区别。  浅拷贝是按位拷贝对象，它会创建一个新对象，如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址。 深拷贝对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容。  数组和链表数据结构区别，及其各自的时间复杂度。 数组与链表的区别\n逻辑结构、物理结构、访问、修改、内存管理\nerror和exception的区别，CheckedException，RuntimeException的区别。    checked Exception：代表程序不能直接控制的无效外界情况（如用户输入，数据库访问，网络异常，文件访问和丢失等），除了Error和RuntimeException及其子类之外的异常，需要try catch处理或throws声明抛出异常。 Unchecked Exception：指的是程序设计bug或逻辑错误，并且在运行时无法恢复，包括系统异常，语法上不需要声明抛出异常。 Error：一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。  常见运行时异常。  NullPointerException - 空指针引用异常 ClassCastException - 类型强制转换异常。 IllegalArgumentException - 传递非法参数异常。 ArithmeticException - 算术运算异常 ArrayStoreException - 向数组中存放与声明类型不兼容对象异常 IndexOutOfBoundsException - 下标越界异常 NegativeArraySizeException - 创建一个大小为负数的数组错误异常 NumberFormatException - 数字格式异常  双亲委派机制不能加载新建的包名相同的包 如果包名相同不可以，因为根据类加载的双亲委派机制，会去加载父类，父类发现冲突了String就不再加载了，但是如果包的名不同就可以重写。\njava.lang.Object对象hashCode和equals方法 为什么要重写hashCode()方法和equals()方法以及如何进行重写\n在定义类时，我们经常需要判断两个对象是否相等，当希望两个不同对象的某些属性值相同时就认为他们相同，所以我们要重写equals()方法。而默认的equals方法只能比较两个引用所指向的对象内存地址是否一致。此外，当需要将自定义类放入map或者set中时，也需要重写equals方法。\n泛型的作用，泛型擦除 参数化类型，提高方法利用性。把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型。\n泛型作用：\n 提高代码复用性 减少强制类型转换  泛型擦除：Java编译后的字节码文件中不包含泛型类型信息，因为虚拟机没有泛型类型对象。在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object。\nJava 中的泛型基本上都是在编译器这个层次来实现的。在生成的 Java字节代码中是不包含泛型中的类型信息的。泛型擦除在编译器编译的时候发生。\n序列化相关介绍 Java序列化\n 什么是序列化  序列化：将对象写入到IO流中 反序列化：从IO流中恢复对象 所有需要保存到磁盘或者在网上传输的java对象都必须是可序列化的。   怎么序列化：  继承Serializable接口或者Externalizable接口 保证类内部所有引用类型均可序列化 （使用transient关键字选择不需要序列化的字段。） 使用ObjectOutputStream对对象进行序列化   序列化存在的问题下午 4:14 21/1/24  java序列化算法不会重复序列化同一个对象，只会记录已序列化对象的编号。如果序列化一个可变对象（对象内的内容可更改）后，更改了对象内容，再次序列化，并不会再次将此对象转换为字节序列，而只是保存序列化编号。   反序列化存在的问题  如果Java应用可以对任意数据做了反序化处理，那么攻击者可以通过构造恶意输入，让反序列化产生非预期的对象，非预期的对象在产生过程中就有可能带来任意代码执行。可以限定可以进行反序列化的对象类型来减少漏洞影响。    java8新特性 Java8新特性\n Lambda表达式 接口的默认方法和静态方法 方法引用 （Java8特性之方法引用）（方法引用初始化，accept方法接收参数） 重复注解及增加注解使用场景 更好的类型推断 （泛型和lambda） 引入一些新的库文件  Java注解和元注解 注解是一种标记，使类或接口附加额外信息，帮助编译器和 JVM 完成一些特定功能，例如@Override 标识一个方法是重写方法。\n元注解则是可以注解到别的注解上的注解。被注解的注解称为组合注解。\n Java.lang中注解  @Override：检查方法是否为重写方法（报编译错误 @Deprecated：标记过时方法（报编译警告 @SuppressWarnings：忽略注解中声明警告   Java.lang.annotation中注解  Java SPI 高级开发必须理解的Java中SPI机制\nSpi(service provider interface)，本质是一种典型的面向接口编程。目地是在不修改代码的情况下，替换掉代码里接口的具体实现类。核心思想是解耦。\n实现步骤：定义一组接口，写出接口的多个实现。建立services目录，目录中新增以接口命名的文件，内容是所有要应用的实现类。最后在代码中使用ServiceLoader来加载配置文件，即可得到所有存在的接口实现。\nJVM JVM运行时数据区域  程序计数器：是当前线程正在执行的字节码的行号指示器。该区域不会有OutOfMemoryError。本地方法中计数器值为空。每个线程都会有自己独立的程序计数器。 Java虚拟机栈：线程私有区域，每个方法执行时，jvm都会创建一个栈帧用于存储局部变量表、操作数栈、动态连接和方法出口等。 本地方法栈：存放某些本地方法 堆：下面有 方法区：存放Java方法  栈内存溢出场景 如果方法的嵌套调用层次太多(如递归调用),随着java栈中的帧的增多，最终导致这个线程的栈中的所有栈帧的大小的总和大于-Xss设置的值，就会有StackOverflowError。\nJVM故障处理工具  Jps：虚拟机进程状况工具 Jstat：虚拟机统计信息监视工具 Jinfo：Java配置信息工具  JVM的内存结构，Eden和Survivor比例。 JVM内存结构：堆内存、栈和方法区\n堆的初始大小为物理内存1/4，上限256M，最大为物理内存一半，上限2GB。（存疑）\n栈的默认大小为1024KB。\n 堆内存：存放大多数的对象实例  新生代  Eden survivor(from) survivor(to)   老生代   方法区（堆内存持久代）：存放类信息、常量、静态变量等数据 栈：存放局部变量表、操作栈、方法出口等信息  Java虚拟机栈 本地方法栈    此外还有程序计数器区域，该区域不会发生OutOfMemoryError.\nJVM内存结构\nJVM内存划分原理 java中最大的特点在于其具备良好的垃圾收集特性。堆内存的分区都是为了更好地执行垃圾回收。\n整个JVM中的GC的处理机制：对不需要的对象进行标记，而后进行清除。\n 老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比MinorGC长得多,所以需要分为Eden和Survivor。Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生。 新生代中采用复制算法，因为新生代gc比较频繁、对象存活率低，用复制算法在回收时的效率会更高，也不会产生内存碎片。但复制算法的代价就是要将内存折半，为了不浪费过多的内存，就划分了两块相同大小的内存区域survivor from和survivor to。在每次gc后就会把存活对象给复制到另一个survivor上，然后清空Eden和刚使用过的survivor。  JVM GC流程及其常用参数 虚拟机GC流程\nJVM常用参数\n常见垃圾收集器及其特点 Java垃圾收集器\n Serial收集器 Parnew收集器 Parallel Scavenge收集器 Serial Old收集器 Parallel Old收集器 CMS收集器 G1收集器 ZGC  g1和cms区别   Cms收集器：CMS收集器是一种以获取最短回收停顿时间为目标的收集器，基于标记清除算法实现，其运行过程如下：\n 初始标记：标记GC roots能直接关联到的对象（stop the world） 并发标记：沿着上个阶段关联到的对象继续查找 重新标记：修改并发标记期间的标记变化对象记录 并发清除    G1收集器：具有如下特点：\n 分代收集，可以不需要其它收集器配合，独立管理JVM堆 空间整合，采用标记整理算法实现 可预测的停顿 其步骤也与CMS收集器基本相同    CMS和G1区别：\n CMS目标是提供最小停顿时间，G1为提供可预测的停顿。 CMS使用标记清除算法实现，G1使用标记整理算法。 CMS仅提供对老年代的垃圾处理，G1可以对整个堆进行管理。  JVM回收卡表\n垃圾回收算法的实现原理  判断对象存活算法  引用计数法：被引用计数器加一，引用失效计数器减一，计数器为零则标为垃圾。无法解决循环引用问题 根搜索法（可达性分析法）：基本思路是通过一系列的名为“GC Roots”（引用对象）的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。引用有如下分类：  强引用：不会被回收。如Object obj = new Object()即强引用 软引用：内存不够被回收 弱引用：下一次垃圾收集被回收 虚引用：随时可能被回收     垃圾回收算法 (JVM)  标记-清除算法 标记-整理算法 复制算法 分代收集算法    Jvm使用分代收集算法，新生代中使用复制算法；老年代中使用标记清理或者标记整理算法。\nJvm垃圾回收算法\n类、常量的废弃判定 类废弃：\n1. 实例都已经被回收\n2. Classloader被回收\n3. Class对象已经被回收（无法被反射）\n常量废弃：没有对象引用常量，则标为废弃常量\n内存溢出排错机制 Java堆内存溢出分析\n在虚拟机中添加参数(XX:+HeapDumpOnOutOfMemoryError/XX:HeapDumpPath)，获取JVM堆内存使用情况文件。\n 分析内存占用-时间表  尖峰状：正常状态 随时间增加：内存泄露   分析内存占用饼图  十种JVM内存溢出的情况\n根据异常信息确定是哪部分内存溢出：\n  堆内存溢出\n  java.lang.OutOfMemoryError:Java heap space （正常溢出）\n 适当调整-Xms和-Xmx两个jvm参数 调试观察内存使用峰值时程序运行情况，尽量避免大批量使用大号对象 提高请求执行速度，早执行垃圾回收    堆内存泄漏 （将引用指向null后，可以减少指向对象的引用，从而方便垃圾回收器回收对象）\n 短周期对象被长周期引用持有 Set、Map容器使用默认equals方法    垃圾回收超时内存溢出（JVM消耗大量时间执行GC，而回收少量堆内存）\n 减少对象生命周期，使JVM能更好进行垃圾回收      Metaspace内存溢出（系统的代码或引用的第三方包非常多或者通过动态代码生成类加载等方法）\n  java.lang.OutOfMemoryError: Metaspace\n 减少第三方包引用 检查动态代码生成框架性能      直接内存溢出\n  java.lang.OutOfMemoryError: Direct buffer memory（javaNIO框架中经常出现）\n 设置参数-XX:MaxDirectMemorySize，并及时clear内存。      栈内存溢出\n  java.lang.StackOverflowError\n 调高-Xss大小，减少递归调用      线程空间溢出\n Heap空间设置过大，系统有线程总数限制，程序中控制使用线程    超出交换区内存溢出\n  数组超限内存溢出\n  系统杀死进程内存溢出\n  类加载器和类加载过程，如何打破双亲委派 JVM三种预定义类型类加载器\n  启动类加载器（JAVA_HOME/lib/）\n  其他类加载器\n  扩展类加载器 （JAVA_HOME/lib/ext）\n  应用程序类加载器（classpath）\n    类加载过程：\n 加载：通过类的全限定名获取类的方法区运行的数据结构 验证：确保class文件符合JVM的要求 准备：为static变量分配内存 解析：将符号引用转换为直接引用 初始化：执行类构造器初始化   双亲委派机制：当某个类加载器需要加载某个.class文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。 打破双亲委派机制：双亲委派机制只是JVM规范要求。自己实现的ClassLoader只要针对某些特殊类自行处理，非处理范围内的类调用super方法即可。  创建对象的过程  加载、验证：当 JVM 遇到字节码 new 指令时，首先将检查该指令的参数能否在常量池中定位到一个类的符号引用，并检查引用代表的类是否已被加载、解析和初始化，如果没有就先执行类加载。 准备：在类加载检查通过后虚拟机将为新生对象分配内存。 解析：内存分配完成后虚拟机将成员变量设为零值，保证对象的实例字段可以不赋初值就使用。 设置对象头，包括哈希码、GC 信息、锁信息、对象所属类的类元信息等。 初始化：执行 init方法，初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。  对象分配内存的方式  指针碰撞：当使用标记-整理算法时，一般使用该方法。被使用过的内存放在一边，空闲的放在另一边，中间放着一个指针作为分界指示器，分配内存就是把指针向空闲方向挪动一段与对象大小相等的距离。 空闲列表：当使用标记-清除算法时，可以使用该方法。当Java堆内存不规整，虚拟机必须维护一个列表记录哪些内存可用，在分配时从列表中找到一块足够大的空间划分给对象并更新列表记录。  一般来说，当使用Serial/ParNew收集器时，系统采用指针碰撞；使用CMS时，采用空闲列表。\n对象在堆内存中的存储布局可分为对象头、实例数据和对齐填充。\n 对象头：占12B。包括对象标记和类型指针。对象标记存储对象自身的运行时数据，类型指针存储对象指向其类型元数据的指针（用于确定其属类）。 实例数据 对齐填充：将对象大小填充为最小单位的倍数。  并发场景的内存分配 一般有两种处理方案：\n 同步分配：对分配内存空间的动作做同步处理。使用CAS机制实现。 预分缓冲内存：对于每个线程在Java堆中预先分配一小块内存，分配操作在预留内存中进行。当使用完后，再分配新的私有内存。该方案称为TLAB分配。  JAVA的反射机制 Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。 这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。 反射被视为动态语言的关键。（可动态获取对象的类，以及类的成员变量和方法）\nJVM控制台命令 深入理解JVM—-JDK的命令行工具\n常用JVM参数 -Xms：初始堆大小\n-Xmx：最大堆大小\n-XX:NewSize=n：年轻代大小\n-XX:NewRatio=n：年轻代和年老代的比值\n-XX:SurvivorRatio=n：年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个\n-XX:MaxPermSize=n：设置持久代大小\n-Xss1024k：单个线程栈\n常见虚拟机参数：  -server -Xms512m -Xmx512m -Xss1024K\n  -XX:PermSize=256m -XX:MaxPermSize=512m -\n  XX:MaxTenuringThreshold=20XX:CMSInitiatingOccupancyFraction=80 -\n  XX:+UseCMSInitiatingOccupancyOnly。\n 依次为初始堆容量， 最大堆容量，线程栈容量，永久代初始容量，永久代最大容量，垃圾年龄，使用CMS作垃圾回收的开始容量比，使用手动定义初始化开CMS收集。\nJVM参数设置与分析\nJava编译和执行的过程 Java代码编译和执行的整个过程\n 编译：编写完源文件之后，程序会先被编译为.class文件。Java编译一个类时，如果这个类所依赖的类还没有被编译，编译器就会先编译这个被依赖的类，然后引用，否则直接引用，这个有点象make。如果java编译器在指定目录下找不到该类所其依赖的类的.class文件或者.java源文件的话，编译器话报“cant find symbol”的错误。编译后的字节码主要分常量池和方法字节码两部分。常量池记录token（名字）和符号引用等，方法字节码存放各方法的字节码。 运行：java类运行可分为类的加载和类的执行。类的加载是当程序第一次使用某类时，才去加载类（延迟加载）。  程序运行具体步骤：\n （编译、加载）在编译好java程序得到MainApp.class文件后，在命令行上敲java AppMain。系统就会启动一个jvm进程，jvm进程从classpath路径中找到一个名为AppMain.class的二进制文件，将MainApp的类信息加载到运行时数据区的方法区内，这个过程叫做MainApp类的加载。 （执行）然后JVM找到AppMain的主函数入口，开始执行main函数。 （延迟加载）main函数的第一条命令是Animal animal = new Animal(“Puppy”);就是让JVM创建一个Animal对象，但是这时候方法区中没有Animal类的信息，所以JVM马上加载Animal类，把Animal类的类型信息放到方法区中。 （分配内存）加载完Animal类之后，Java虚拟机做的第一件事情就是在堆区中为一个新的Animal实例分配内存,然后调用构造函数初始化Animal实例，这个Animal实例持有着指向方法区的Animal类的类型信息（其中包含有方法表，java动态绑定的底层实现）的引用。 （调用方法）当使用animal.printName()的时候，JVM根据animal引用找到Animal对象，然后根据Animal对象持有的引用定位到方法区中Animal类的类型信息的方法表，获得printName()函数的字节码的地址。 开始运行printName()函数。  操作系统 Linux系统常见内核参数 使用sysctl –a查看内核参数。\nLinux内核参数说明 Linux内核参数优化\n kernel.hostname：设置主机名 kernel.ostype：操作系统类型 net.ipv4.tcp_fin_timeout：系统默认超时时间 net.ipv4.tcp_keepalive_time：keep_alive使用时，tcp发送相关消息的频度，缺省120分钟。 net.ipv4.ip_local_port_range：用于向外连接的端口范围。（10000 65536） net.ipv4.tcp_max_syn_backlog：允许的SYN队列长度。  常见系统调用 系统调用的类型\n 文件操作类（设备管理）：creat/open/write/read/close 进程类：fork/wait/exit 时间类 通信类 保护类  Linux下IO模型  同步阻塞IO：调用后当场返回，可能为error 同步非阻塞IO：调用后出结果再返回，可能等待 多路复用IO：多IO时，使用一个线程统一轮询所负责的IO，当数据准备好即开始处理 信号驱动式IO：Socket安装一个信号处理函数，当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。 异步IO：用户进程发出请求后会继续运行，等socket数据准备好以后，内核再会向进程发送通知。  epoll和poll区别。   Poll：\n 单个进程可监视的socket有限 （select缺点，已修正） 访问描述符时，只要有活跃的socket，就需要遍历所有监视的socket 用户空间和内核空间需要传递整体的socket数组，开销很大 Poll为水平触发，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。    Epoll：\n 提供边缘触发和水平触发两种工作模式，方便用户去除不需要关心的socket事件 没有最大连接数限制 只有活跃的连接才会被处理 使用mmap文件映射加速内存和内核空间的消息传递    Epoll相对poll而言，时间开销小，传递空间开销小，传递速度快，提供多种工作模式\n常用Linux命令 ls/cd/mkdir/cp/pwd/rmdir/rm/mv/vim/cat/tail/grep/tar/gzip/unzip/help/kill/ps/ping/exit/df/top/shutdown/chmod\n 用一行命令查看文件的最后五行 ：tail –n 5 file 用一行命令输出正在运行的java进程 ：ps –ef | grep java  操作系统线程切换过程  保存进程状态； 更新PCB； PCB放入等待队列； 修改新进程PCB信息，并执行进程； 执行完后，从队列中取出旧PCB，恢复进程被切换时的上下文并继续执行；  线程切换和进程切换的区别：区别在于地址空间。对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。\n 切换页目录以使用新的地址空间； 切换内核栈和硬件上下文；  常用进程调度算法  先来先服务调度算法 短进程优先调度算法 时间片轮转法 多级反馈队列调度算法 优先权调度算法（抢占式、非抢占式）  各操作系统\n Linux区别实时进程和普通进程，普通进程采用动态优先调度，实时进程采用先来先服务和时间片轮转。 Unix使用多级反馈队列调度法，不区别优先级 Windows基于线程进行调度，即始终运行优先级最高的就绪线程，同一优先级下使用时间片轮转算法进行调度。  存储管理 存储管理之页式、段式、段页式存储\n分段和分页的区别：\n 页是物理单位，是系统管理需要；段是逻辑单位，是用户需要 页大小固定；段长度不固定，通常在编译器编译源程序时决定 页的地址空间为一维；段的地址空间为二维  并发 进程和线程的区别 进程和线程的区别\n守护线程和用户线程   Java中的线程可以分为守护线程和非守护线程。Jvm启动时，除了主线程外，如垃圾收集器、引用处理守护进程等全部为守护线程。守护线程一般用于维护用户线程，优先级较低。（类后台线程）\n  新线程会继承创建它的线程的守护状态。\n  守护线程有如下特点：\n 设置守护线程需要事先设置 守护线程优先级很低，随时可能发生中断，不应该用于cpu计算及io操作 Jvm结束时，守护线程会自动消亡 线程池不能使用守护线程    用户级线程和内核级线程 两者的区别在于线程切换时是否需要内核参与。\n（txc待补充标记）\n进程间通信方式 包括管道、信号量、共享内存、消息队列等等\n 管道：管道是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。 信号：信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。例如程序结束信号、定时器信号等 共享内存 消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。  多线程的几种实现方式，线程安全概念 Java里实现方式包括：继承Thread类、实现Runnable接口、实现Callable接口。\n线程安全：线程安全是多线程编程时的计算机程序代码中的一个概念。 在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。（线程运行时的数据不会被其它的线程修改，导致影响最后结果）。\nvolatile的原理作用 volatile关键字解析\n在多线程编程时，经常会遇到三个问题：原子性问题，可见性问题，有序性问题。\n在java内存模型中，只保证基本读取和赋值是原子性操作。\n 防止重排序 实现可见性  不能代替锁，volatile不能保证修饰变量在操作时的原子性。此外synchronized能保证操作的原子性和实现可见性。\nFinal的可见性问题 final 可以保证可见性，被 final修饰的字段在构造方法中一旦被初始化完成，并且构造方法没有把 this引用传递出去，在其他线程中就能看见 final 字段值。\n但在final变量初始化前后，可能会存在线程访问前后变量值不一致的问题。为了解决该问题，JSR-133中为final域添加了重排序规则。\nsleep和wait区别。 wait()和sleep()的关键的区别在于，wait()是用于线程间通信的，而sleep()是用于短时间暂停当前线程。 更加明显的一个区别在于，当一个线程调用wait()方法的时候，会释放它锁持有的对象的锁，但是调用sleep()方法的时候，不会释放他所持有的锁。\nsleep和sleep(0)区别。  Sleep(0)：如果线程调度器的可运行队列中有大于或等于当前线程优先级的就绪线程存在，操作系统会将当前线程从处理器上移除，调度其他优先级高的就绪线程运行；如果可运行队列中的没有就绪线程或所有就绪线程的优先级均低于当前线程优先级，那么当前线程会继续执行，就像没有调用Sleep(0)一样。 当 timeout \u003e 0时，如：Sleep(1)，会引发线程上下文切换：调用线程会从线程调度器的可运行队列中被移除一段时间，这个时间段约等于timeout 所指定的时间长度。通常情况下，系统的时间精度为 10ms，那么指定任意少于 10 ms但大于 0 ms 的睡眠时间，均会向上求值为 10 ms。  Lock与Synchronized区别 。 Lock是一个接口，ReentrantLock（可重入锁）已经实现了Lock接口，可以直接使用。\n一般考虑优先使用synchronized。\nSynchronized原理，常见锁解释 Synchronized原理：通过保证方法或者代码块在运行时，同一时刻只有一个方法进入临界区来实现同步，同时还可以保证共享变量的内存可见性。\n在jdk1.6之前，synchronized属于重量级锁，由于直接对应到底层，加锁会涉及到内核态和用户态的转换，所以效率较低；jdk1.6以后，jvm对synchronized进行了大量优化，表现为synchronized会随着锁竞争的情况逐渐升级，锁升级由低到高分别为无锁、偏向锁、轻量级锁和重量级锁。为保证锁获得和释放的效率，锁不可降级。此外，synchronized中引入了自适应自旋、锁消除、锁粗化、轻量锁和重量锁。\n重排序：所有的动作都可以为了优化而打乱顺序，但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致的。\n 自旋锁：让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。避免频繁阻塞和唤醒线程。 适应自旋锁：指锁的自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。 锁消除：当JVM检测到某变量不会出现共享数据竞争时，可以消除掉加锁操作。 锁粗化：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。 偏向锁：即锁会偏向于当前已经占有锁的线程，用以减少锁在线程间来切换的开销。 重量级锁：也称监视器锁。直接对应于底层的互斥量。因为涉及系统调用和用户态切换等，成本较高。 轻量级锁：不依赖于底层，减少加锁成本的锁。适合于少量锁竞争的场合。 可重入锁：可反复加锁。 公平锁/非公平锁：每个线程抢占锁的顺序是否为先后调用lock方法的顺序依次获取锁，类似于排队吃饭。（非公平锁会有再次CAS抢锁的机会） 乐观锁/悲观锁：取数据时以最坏或最好情况考虑。  原子类 包括以下几种：\n AtomicBoolean: boolean类型原子类 AtomicInteger: int类型原子类 AtomicLong: long类型原子类  原子类使用循环CAS操作实现。CAS操作内部实现原理是缓存锁，在其操作期间，会修改对应操作对象的内存地址。同时其会保证各个处理器的缓存是一致的，如果处理器发现自己的数据对应的内存地址被修改，就会将当前缓存的数据处理为无效，同时该处理器会重新从系统内存中把数据处理到缓存中。\nJUC并发工具 JUC即java.util.concurrent。里面包括：Lock类、atomic类、sync类（同步器）、collections类、executors线程池类\nJava线程池 Java线程池解析\n通过重用存在的线程，来减少线程创建、消亡的开销。\nExecutors类创建线程池方法\n newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO,LIFO, 优先级)执行。  ThreadPoolExecutor参数含义：\n coreSize：当线程池中线程数未达coreSize时，不管现有线程是否空闲都会新建线程。 maxSize：线程数达到该值时继续添加任务就会触发RejectedExecutionHandler。 keepAliveTime - 当线程数大于核心时，为终止前多余的空闲线程等待的最长时间。用以在线程池使用较少时减少资源消耗。 workQueue - 用来储存等待执行任务的队列。 handler - 拒绝策略。  Java线程池注意：\n  Executors类创建线程池时，其实就是调用ThreadPoolExecutor类构造方法实现。\n  在创建了线程池后，默认情况下，线程池中并没有任何线程，等到有任务来才创建线程去执行任务，当创建的线程数等于corePoolSize时，会加入设置的阻塞队列。当队列满时，会创建线程执行任务直到线程池中的数量等于maximumPoolSize。若线程数量已达到maxsize，则会触发handler方法执行拒绝策略。\n  使用线程池时，尽量使用ThreadPoolExecutor创建。NewCachedThreadPool对线程数没有限制，NewFixedThreadPool和newSingleThreadExecutor对阻塞队列长度没有限制（两线程程使用无界队列构造）。使用上述方法创建的线程池都有耗尽内存引发OOM的风险。\n FixedThreadPool阻塞队列是无界队列，永远不会拒绝任务。singleThreadExecutor相同，但其coreSize固定为1。 CachedThreadPool可以无限扩大线程数量，coreSize为0，maxSize为无限大。KeepAliveTime为60s。使用SynchronousQueue装任务，即任务一到当场开始处理。 SchduledFutureTask使用DelayQueue（封装了PriorityQueue，根据时间顺序处理），任务执行结束后会再次放回队列定时执行。    线程池中使用阻塞队列来保存待处理任务。SynchronousQueue即存即取（无缓存），linkedBlockingQueue可缓存任务。\n  Java阻塞队列  ArrayBlockQueue：一个由数组支持的有界阻塞队列。此队列按FIFO（先进先出）原则对元素进行排序。创建其对象必须明确大小，像数组一样。 LinkedBlockQueue：一个可改变大小的阻塞队列。此队列按FIFO（先进先出）原则对元素进行排序。创建其对象如果没有明确大小，默认值是Integer.MAX_VALUE。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。 PriorityBlockingQueue：类似于LinkedBlockingQueue，但其所含对象的排序不是FIFO，而是依据对象的自然排序顺序或者是构造函数所带的Comparator决定的顺序。 SynchronousQueue：同步队列。同步队列没有任何容量，每个插入必须等待另一个线程移除，反之亦然。  线程池关闭方式  关闭线程：  sleep：系统直接关闭线程 interrupt：给线程打上中断标记，由线程自主关闭。（若在运行状态，则仅将中断标记设为True；若在休眠状态wait、sleep、io则会退出阻塞并抛出InterruptedException）   关闭线程池：  shutdownNow：线程池拒接收新提交的任务，同时立刻关闭线程池并结束线程池内任务 shutdown：线程池停止接收新任务，线程池内任务执行完毕后关闭线程池    三个线程循环打印abc三个字母  每个线程只打印一种字母：设置一个当前打印序号变量，给对象加锁。建立三个线程，分别根据打印序号变量执行打印任务ABC。若获取到锁的对象发现并非轮到自己打印，则睡眠。当有线程成功打印字母后，就唤醒其它线程。 每个线程可以打印多种字母：设置当前打印序号变量，给变量加锁。建立三个线程，根据当前打印序号变量执行打印任务。  ThreadLocal  作用：ThreadLocal提供了线程的局部变量，每个线程都可以通过set()和get()来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，实现了线程的数据隔离。 原理：ThreadLocal中数据存储在内部类ThreadLocalMap中，每个线程均含有一个ThreadLocalMap类型的成员变量threadLocals，它存储本线程中所有ThreadLocal对象及其对应的值。即获取ThreadLocal实际是获取线程的threadLocals变量。 （Thread为每个线程维护了ThreadLocalMap这么一个Map，而ThreadLocalMap的key是LocalThread对象本身，value则是要存储的对象） 注意：可能引起内存泄露。因为ThreadLocal是弱引用，而Entry的value是强引用。因此当ThreadLocal被回收后，value并不会被释放。 **ThreadLocalMap中不使用链表结构解决冲突，而是使用线性探测的方法。**即遇到碰撞时使用固定算法寻找一定步长的下个位置，直到找到能够存放的位置。（线性探测法）  交替锁实现并发安全链表 使用交替锁，增删改分别对涉及到的节点加锁。\n 增加、删除：对涉及的前后两个节点加锁 修改：对修改的当前节点加锁  无锁数据结构 主要包括原子类Atomic及JUC，原子类主要通过CAS实现，Lock、Semaphore、ReentrantLock等主要通过AQS实现\njava同步机制wait和notify。 当线程执行wait()时，会把当前的锁释放，然后让出CPU，进入等待状态。\n当执行notify/notifyAll方法时，会唤醒一个处于等待该对象锁 的线程，然后继续往下执行，直到执行完退出对象锁锁住的区域（synchronized修饰的代码块）后再释放锁。\nCAS机制，ABA问题。 CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。\n对CAS涉及的变量增加版本号。\ncountdownlatch和cyclicbarrier Java并发编程：CountDownLatch、CyclicBarrier和Semaphore\n CountDownLatch：类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。 CyclicBarrier：字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。  AbstractQueuedSynchronizer，加锁和解锁的流程，独占锁和公平锁区别 AbstractQueuedSynchronizer的介绍和原理分析\nAbstractQueuedSynchronizer：AQS提供了一个基于FIFO队列，可以用于构建锁或者其他相关同步装置的基础框架。该同步器利用了一个int来表示状态。使用的方法是继承，子类通过继承同步器并需要实现它的方法来管理其状态，管理的方式就是通过类似acquire和release的方式来操纵状态。然而多线程环境中对状态的操纵必须确保原子性，因此子类需要使用这个同步器提供的以下三个方法对状态进行操作:\n java.util.concurrent.locks.AbstractQueuedSynchronizer.getState() java.util.concurrent.locks.AbstractQueuedSynchronizer.setState(int) java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState(int, int)   独占锁：独占锁锁定的资源只允许进行锁定操作的程序使用，其它任何对它的操作均不会被接受。 共享锁：共享锁锁定的资源可以被其它用户读取，但其它用户不能修改它。  synchronized修饰静态方法和非静态方法区别。  Synchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”。 Synchronized修饰静态方法，实际上是对该类对象加锁，俗称“类锁”。  ConcurrentLinkedQueue和LinkedBlockingQueue ConcurrentLinkedQueue为非阻塞队列，使用CAS+自旋操作实现， LinkedBlockingQueue为阻塞队列，使用锁机制实现。\n两者都是线程安全的队列。\n线程死锁的原因，如何解除线程死锁。 原因包括和预防方案包括：\n 互斥条件 不剥夺条件 （释放资源、重新申请 循环等待条件（顺序申请 请求和保持条件（一次性申请  解除方法：资源剥夺法、撤销进程法\n多线程协调方案 JUC工具里有处理多线程协调的类：\n Semaphore：设置一定数量的令牌，只有获得令牌的线程才能继续运行。 CyclicBarrier：循环栏杆，只有等待线程数到达一定值才会继续运行。 CountDownLatch：倒计时栏杆，只有当倒计时达到0时才会继续运行。  读写锁 ReentrantReadWriteLock：读写锁分为读锁和写锁。多个读锁之间是不需要互斥的，写锁和写锁之间需要互斥。\n ReadWriteLock rwlock = new ReentrantReadWriteLock(); rwlock.readLock().lock(); rwlock.readLock().unlock(); rwlock.writeLock().lock(); rwlock.writeLock().unlock();  缓存？\nJMM概念：重排序，内存屏障，happen-before，主内存，工作内存等。 JVM内存模型相关概念详解\nJava 线程的通信由 JMM 控制，JMM 的主要目的是定义程序中各种变量的访问规则。\nJMM(java memory model)java内存模型是一种虚拟机规范，用于屏蔽掉各种硬件和操作系统的内存访问差异。JMM规定虚拟机使用计算机内存的方式，保证线程安全等。\nJMM中所有变量都存储在主内存，而每条线程都有各自的工作内存，工作内存中保存被线程使用的变量的主内存副本。线程对变量的所有操作都必须在工作空间进行，不能直接读写主内存数据。不同线程间无法直接访问对方工作内存中的变量。这样会产生一个不同线程对同一变量访问的同步问题。JMM用于控制和解决这些问题\n  重排序：为了提供性能，处理器和编译器常常会对指令进行重排序。重排序要确保单线程条件下不会影响程序运行结果。\n  As-if-serial：重排序指令要保证单线程程序的执行结果不能改变。称as-if-serial语义。\n  内存可见性：因为缓存中的数据与主内存的数据并不是实时同步的，所以可能在同一时间点，各cpu核心看到的同一地址的值并不相同。\n  内存屏障：一种CPU指令，用于控制重排序和内存可见性引起的相关问题。即用于保证开始某读写操作前一定先完成一读写操作。Java内存屏障包括：\n LoadLoad屏障 StoreStore屏障 LoadStore屏障 StoreLoad屏障（开销最大，效果最好）    Happens-before：是JMM可以向程序员提供跨线程的内存可见性保证的关系，即JMM下所有指令重排都会符合Happens-before关系。\n  主内存和工作内存：主内存是所有的线程所共享的内存区域，工作内存是每个线程私有的内存区域。（为获得更好的执行性能，java内存模型允许执行引擎使用高速缓存，及对指令进行重排序。JMM规定所有的变量都存在主内存（类似物理内存）中，但每个线程也都有独立的工作内存（类似高速缓存）。线程对变量的所有操作都必须在工作内存中进行，不能直接对主存进行操作。并且各线程间主存相互独立）\n  常见设计模式 常见设计模式\n设计模式可分为：\n 创建型：创建对象时隐藏创建逻辑。包括工厂/抽象工厂/单例/建造者/原型模式 结构型：通过继承和引用实现创建复杂结构的对象。包括适配器/桥接模式/过滤器/组合/装饰器/外观/享元/代理模式 行为型：通过不同的通信方式实现不同行为。包括责任链/命名/解释器/迭代器/中介者/备忘录/观察者/状态/策略/模板/访问者模式。  单例模式、工厂模式、原型模式、代理模式、观察者模式\n  装饰器模式与代理模式（动态代理）区别：java.io 包中，**InputStream字节输入流通过装饰器BufferedInputStream增强为缓冲字节输入流。**这种场景即属于装饰器模式。\n区别于动态代理，装饰器模式的关注点在于给对象动态添加方法，而动态代理更注重对象的访问控制。动态代理通常会在代理类中创建被代理对象的实例，而装饰器模式会将装饰者作为构造方法的参数。\n  适配器模式：适配器模式一般用于将一个类的接口转换成另外一个接口，使得原本由于接口不兼容而不能一起工作的类可以一起工作。java.io包中，InputStream 字节输入流通过适配器 InputStreamReader 转换为 Reader字符输入流。\n  常见设计原则 设计模式七大基本原则\n软件实体包括类、函数等\n 单一职责原则：一个软件实体，仅负责一项任务。 开放-关闭原则：一个软件实体应当可扩展，但不可被修改。 里氏替换原则：子类继承父亲，仅新增，尽量不要修改原功能。 依赖倒转原则：避免高层依赖于低层，使实现依赖于接口。 接口隔离（分离）原则：尽量分离出接口不必要的功能，形成其它接口。 迪米特法则：尽量减少与某个类相关的类数量。 组合/聚合复用原则：尽量使用组合/聚合来代替继承。  算法 常见排序方法 排序根据是否使用外存来分为内部排序和外部排序。\n内部排序又可以根据是否需要比较来分为比较排序和非比较排序。\n字符串压缩算法 行程长度压缩、哈夫曼编码压缩\n字符串压缩算法\n常见算法题  细节在note里 写完题目后一定要大量测试  Z字型变换（二维数组）、整数反转（注意溢出）、盛最多水的容器（双指针）、最接近的三数之和（固定一数后双指针）、K个一组翻转链表、两数相除（位运算作贪心）、下一个排列（找下降、处理相同数字）、缺失的第一个正数（负数在原数组中做标记）、全排列 II（限制交换）、旋转图像（转置后镜像）、字母异位词分组（构造hash）、Pow(x, n)（不要用递归）、第k个排列、编辑距离（动态规划）、搜索二维矩阵（类二叉树移动指针）、二叉树的中序遍历（栈记录已遍历过节点）、验证二叉搜索树（对比子树和父节点）、重建二叉树、单词拆分、最大正方形（高端DP）、寻找重复数（剑指）、最佳买卖股票时机含冷冻期（三状态DP）、水壶问题（贝祖定理求公约数）、 有序矩阵中第K小的元素（优先队列从左上添加）、 01矩阵（两遍DP）、最长重复子数组（DP）、每日温度（递增栈）、矩阵重叠、鸡蛋掉落、排序数组（多复习快排）、使数组唯一的最小增量（线性探测）、最低票价、最佳观光组合、山脉数组中查找目标值、删点成林、有效括号的嵌套深度、最大的团队表现值、判断子序列（贪心）、数值的整数次方（注意负极值溢出）、数字序列中某一位的数字（细节是魔鬼）、回文子串（马拉车算法）、把数组排成最小的数（剑指原题）、\n计算机网络 Java面试常问计算机网络问题 计算机网络面试常见问题\nhttp请求相关属性  Http请求头属性：Accept（期望接收类型）、Referer（请求来源）、Accept-Language（接收语言）、User-Agent（客户端环境）、Content-Type（请求体类型）、Content-Length（请求体长度）、Connection（是否保持连接）、Cookie HTTP响应头属性：Content-Encoding（响应体编码/utf-8）、Content-Type（响应体含类型）、Content-Length（响应体长度）、Content-Location（响应体备用地址）、Content-Language（请求体语言）、Server（服务器类型） 总结：长度，编码方式，语言，编码类型，环境  TCP连接过程 Cookie和Session区别  Cookie：是客户端保存用户信息的一种机制，用来记录用户的一些信息，实际上Cookie是服务器在本地机器上存储的一小段文本，并随着每次请求发送到服务器。 Session：在计算机中，尤其是在网络应用中，称为“会话控制”。Session对象存储特定用户会话所需的属性及配置信息。当用户请求来自应用程序的 Web页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。   （存放位置不同）cookie数据存放在客户的浏览器（客户端）上，session数据放在服务器上，但是服务端的session的实现对客户端的cookie有依赖关系的。 （安全性）cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。 （服务器性能）session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE。  Java servlet简介 Java servlet是一个接口：\nTooken使用 授权Auth区别：\n  Cookie auth：在服务器端创建session，将sessionid交给客户端，用来实现状态管理。\n  JWT(json web token)：在服务器认证后，在服务器将用户属性打包生成JSON对象发回。包括header（token属性），payload（存储数据），signature（签名）。有如下优点：\n 支持跨域访问 服务器端不需要存储session，用户信息会随token发过来 非浏览器环境不支持cookie，可以使用token认证机制 可以解决跨站请求伪造的问题    分布式session管理方案  Session复制：通过修改配置，同步所有服务器上保存的session。 Session粘滞：通过绑定请求ip，使相同用户的所有请求都发到同一个服务器上。 Session集中管理：使用redis等技术集中管理session，所有服务器统一到存储中查取session。  DNS使用协议 同时使用TCP和UDP协议\n DNS 响应报文大于 512 字节时，通过 TC 标志位标记为1，会使用 TCP重新查询一遍。 DNS主服务器和辅助服务器之间，进行区域传送时，为了保证稳定以及传输数据太大的原因，也会使用 TCP 协议传输。  TCP粘包和拆包 TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。\n  TCP拆包发生原因\n 应用程序写入字节的大小大于socket发送缓冲区大小 应用程序发送数据大小大于MSS(最大数据报文段)，此时会进行MSS大小的TCP分段 以太网帧playload大于MTU(通信协议某一层最大允许通过的数据包大小)后，进行IP分片。    TCP粘包发生原因\n 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去 接收数据端的应用层没有及时读取接收缓冲区中的数据    粘包拆包解决办法\n 包首部添加长度 封装数据包为固定长度 给数据包设置边界    一次完整的HTTP请求过程 一次完整的HTTP请求过程\nTCP如何保证可靠传输   确认和重传\n  数据校验\n  数据合理分片和排序\n  流量控制（接收方来不及处理）（作用于接收者）\n 滑动窗口（累计确认，根据接收端反馈调整窗口大小）    拥塞控制（网络拥塞）（作用于网络）\n 慢开始，拥塞避免 快重传，快恢复    URI和URL区别 URL是URI的一个子集。 在《HTTP权威指南》一书中，对于URI的定义是：统一资源标识符；对于URL的定义是：统一资源定位符。 二者的区别在于，URI表示请求服务器的路径，定义这么一个资源。 而URL同时说明要如何访问这个资源（http://）。\nHTTP缓存 （txc待补充标记）\nHTTP和HTTPS的区别  https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 https默认是长连接，http需要使用keep-alive来保证。  HTTPS加密过程 https在传统的http和tcp之间加了一层用于加密解密的ssl/tls层（secure sockets layer/transport layer security）\n第一次请求的代价很大，之后通信会使用第一次通信的协商密钥。\n 数字签名：对传输内容进行hash生成摘要，再用私钥对摘要加密，即生成数字签名。数字签名用公钥解密后再与内容hash进行对比，即可得知内容有没有经过修改。 数字证书：证书中心（CA）会使用专用私钥对某公钥及公钥相关信息进行加密，生成文件即为数字证书。向证书中心请求拿到数字证书后，使用CA的公钥即可得到通信方的身份确认和真实公钥。  http token：类似于cookie，安卓向服务器发送请求时并不会带上sessionid，所以需要token机制来实现。流程为：客户端发起登录请求，登录成功后，服务器签发一串token。客户端以后访问就带token做身份验证。常见token验证方法有JWT等。\nHTTP1.X和HTTP2.0的区别  1.X解析基于文本，而2.0基于字节。 2.0可以实现多路利用，即一个连接中可以混合多个request，在服务端再分开。 2.0对header进行了压缩（双方均缓存header fields表，用以减小需要传输的大小） 2.0新增了服务端推送功能  ARP协议内容 理解ARP协议\n数据库 数据库常见面试题\n数据库概念 存储过程、数据库依赖关系（部分函数依赖，全部函数依赖）、数据库三范式、视图、索引（聚集索引，非聚集索引）、事务、事务隔离级别（未提交读，已提交读，可重复读，可串行化）、悲观锁（先获取锁再执行）、乐观锁（先执行再检查）、（超键，候选键，主键、外键）、SQL约束（NOT NULL，UNIQUE，PRIMARY KEY，FOREIGN KEY，CHECK）、归档模式、Mysql存储引擎（innodb，MyIASM，MEMORY）、mysql权限表、数据库锁、SQL优化\n数据库基础定义   存储过程：事先编译并保存在数据库中的SQL语句集合。\n  事务特性：原子性、隔离性、持久性、一致性（redo/undo log实现acd，锁实现i）\n JDBC关闭auto-commit模式后通过手动提交和异常回滚可实现事务 a:atomicity/c:consistency/i:isolation/d:durability    数据库三范式：1. 列的原子性 2. 其它属性完全依赖于主键 3. 非主键之间不能相互依赖\n  数据库隔离级别：未提交读、已提交读、可重复读（innodb 默认（mysql默认引擎））、可串行化\n  数据库并发事务问题：脏读、不可重复读、幻读\n  触发器：满足定义条件时触发，并执行触发器中定义的语句集合（大量消耗资源）\n  数据各种键：\n 超键：能唯一确定元组的属性集 候选键：不含多余属性的超键 主键：由用户确定的用于标识的候选键    数据库锁\n 表级锁：开销小，不会出现死锁，冲突可能大 行级锁：开销大，可能出现死锁，冲突可能小 页级锁：开销在上两者之间，可能出现死锁    Btree索引和Hash索引   Btree索引可以用在单行数据查找和范围数据查找，还可以用于非通配符开头的常量\n  Hash索引只能用于一次定位数据=，一次定位时效果远好于Btree，但其：\n 不能用于范围查找 联合索引只能使用所有索引 无法优化排序操作 只能在索引中存储指针，不能直接指向数据    InnoDB引擎锁算法 包括单行锁（Record lock），间隙锁（gap lock），next-key lock。如下图：\n使用算法规则如下：\n  不通过索引条件查询时，innodb会锁定表中所有记录。\n  通过索引实现行锁。只要索引相同，不同记录都会同时被锁。\n  索引为唯一索引时，next-key lock会降级为record lock。\n  使用next-key lock来避免幻读问题。（锁定查找范围内的数据，限制插入）\n InnoDB中若查询索引为唯一索引或主键，则会将next-key Lock降级为record lock。若为辅助索引，不仅会锁住当前范围，还会锁下一键值范围。    InnoDB行锁算法讲解（没看懂）\nMVCC原理 MVCC（Multi Version Concurrency Control），即多版本并发控制。与MVCC相对的，是基于锁的并发控制（Lock-Based Concurrency Control）. InnoDB存储引擎默认隔离级别REPEATABLE READ，通过MVCC解决了幻读的问题。MVCC不能解决幻读问题（参考，迷惑）Mysql innoDB中的可重复读并不能保证避免幻读，避免幻读需要应用到加锁读机制next-key lock实现。\nMVCC使用同时记录多时间点版本的数据来实现并发访问控制。\nMVCC通过在每行记录后面保存两个隐藏的列来实现的。两个隐藏列分别保存了行的创建时间和过期时间。其中存储的时间为系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。\nMVCC具体操作：\n SELECT：InnoDB只查找版本早于当前事务版本的数据行，和版本大于当前事务版本号的删除行（保证事务读取的行在事务开始前已经存在） INSERT：InnoDB新插入的每一行使用当前系统版本号作为行版本号。 DELECT：InnoDB删除的每一行使用当前系统版本号作为行版本号。 UPDATE：InnoDB更新数据时会先插入一行新数据，使用当前系统版本号作为行版本号。再更新当前系统版本号到原来的行，作行删除标识。  数据库索引 索引是对数据库表中一个或多个列的值进行排序的数据结构，以协助快速查询、更新数据库表中数据。索引通常使用b-tree或其变种实现。\n  索引的优点\n 加快数据检索速度 加速表连接 加速分组（GROUP）和排序（ORDER） 唯一性索引还可保证每行数据的唯一性    索引失效场合（可以避免下列场合来作索引优化）Mysql索引失效的几种情况\n 以任意匹配符‘%’开头的like语句 Or语句前后没有同时存在索引 数据类型出现隐式转化 多列索引满足最左匹配原则    索引创建要求\n 指定非空 优先取经常需要搜索、使用where、排序、连接的列    B-tree和b+tree区别：\n N棵子树结点中含有n个关键码 叶子结点中包含所有关键码信息及指针，叶子结点间相互连接 非终端结点为索引部分，仅含有子树根结点中最大或最小关键码    B+tree相对b-tree区别：\n B+树磁盘读写代价更低（由于 B+树在非叶子节点上不含数据信息，因此在内存页中能够存放更多的key，数据存放得更加紧密，具有更好的空间利用率，访问叶子节点上关联的数据也具有更好的缓存命中率） 数据库中存在大量基于范围的查询，更适合B+树（B+树的叶子结点都是相连的，因此对整棵树的遍历只需要一次线性遍历叶子节点即可）    数据库优化 MySQL高性能优化规范建议\n最全SQL优化策略送给你\nSql语句优化（sql必带where），读写分离（主库写从库读），数据类型，范式，拆分，系统配置\n  使用慢查询日志可以定位执行效率很低的SQL语句。\n  数据类型：尽量使用较小的数据类型\n  范式：表设计时符合三范式\n  拆分\n 垂直拆分：可以将不常用字段、大字段、经常使用字段进行独立拆分 水平拆分：可以根据id进行hash，根据hash值存表。或者根据表数据实际意义拆表    系统配置\n 增加TCP支持的队列数 增加innodb缓存池内存innodb_buffer_pool_size及个数innodb_buffer_pool_instances    硬件（花钱换cpu，加内存，使固态）\n  Limit会影响读取速度（limit会重复读取offset+limit前的记录，再根据offset抛弃前方数据）\n  MySql逻辑架构 第一层是服务器层。主要提供连接处理、授权认证、安全等功能。\n第二层是 MySQL核心功能层。包括查询解析、分析、优化、缓存以及日期和时间等所有内置函数，所有跨存储引擎的功能都在这一层实现，例如存储过程、触发器、视图等。\n第三层是存储引擎层。存储引擎负责 MySQL 中数据的存储和提取。服务器通过 API与存储引擎通信，这些API屏蔽了不同存储引擎的差异，使得差异对上层查询过程透明。\n图中每虚线框为一层。\nMyISAM和InnoDB区别  MyISAM不支持事务处理，Innodb支持（InnoDB回滚） MyISAM只有表级锁，InnoDB有行级锁 （MyISAM不适合大并发系统） MyISAM不支持外键 MyISAM速度快于InnoDB 相对来说：MyISAM适合查多写少，InnoDB适合查少写多  Mysql存储引擎的区别\nMysql查询执行路径  客户端发送一条查询给服务器； 服务器先检查该语句是否有权限，若没有直接返回错误信息 服务器检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段； 服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划； MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询； 将结果返回给客户端。  数据库联合索引 联合索引也称复合索引，MySQL从左到右使用索引中的字段，一个查询可以只使用索引中的一部分，但只能是最左侧部分，例如有索引(a,b,c)，即可支持a，a|b，a|b|c三种组合进行查找，该特性称为最佳左前缀特性。\nDrop， delete与truncate区别  Drop删除整张表 Delete删除表部分行，执行后需要提交或回滚 Truncate删除表所有行，但保存表结构  char，varchar，text类型的区别  char(n)，代表字符数最大是n，字符数超过n会被截断。会占用n个字符的空间，即使字符数小于n也会按照n个字符来存，剩下的用空格补齐，但检索的时候尾部空格会被隐藏。N最大255。 varchar(n)，代表字符数最大是n，字符数超过n会被截断。如果字符数小于n，则只会占用字符加上1到2字节的空间，加上的几个字节用来存储数据大小。无空间浪费。N最大65535. text(n)，按照字符数量来占用空间，用2字节记录存储数据大小，这2字节不占用text数据的空间。没有空间浪费，但速度慢。  视图和游标   视图：一种虚拟表，原表列和行的子集，可对视图进行增删改查，一般用于查询。符合要求的修改会被添加到基本表中\n 优点：简化操作，定制数据，安全性 缺点：性能差，更新有限制（with check option） 编写：create or replace view view_student as select * from student    游标：结果集中用于遍历查询结果，类似迭代器\n  Binlog、redolog和undo log 详细分析MySQL事务日志(redo log和undo log)\n详细分析MySQL日志\n  Binlog：也称二进制日志。日志中包含了引起或者可能引起数据库改变（如无匹配行的delete语句）的事件信息，但不包含查询语句。语句以\"事件\"的形式保存，所以包含了时间、事件开始和结束位置等信息。可以简单认为binlog是包含有执行时间的sql更新语句集合。二进制日志可以用于多节点间的主从同步，也可以从二进制日志中恢复数据库。\n  Redolog/undolog：两者都属于innodb事务日志。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。\n redo log通常是物理日志，记录的是数据页的物理修改（区别于binlog），它用来恢复提交后的物理数据页，且只能恢复到最后一次提交的位置。 undo用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。    Redo log和binlog区别\n binlog是存储引擎的上层产生的，和存储引擎无关。而redolog是在innodb层中产生的。Binlog要先于redolog被记录。 binlog记录的是逻辑性的语句，类似于sql语句，而redolog是物理格式上的日志，直接记录数据库中页的修改。 二进制日志只在每次事务提交的时候一次性写入缓存中的日志文件。而redolog在数据准备修改前先写入缓存，然后才对缓存中的数据执行修改操作；而且保证在发出事务提交指令时，先向缓存中的redolog写入日志，写入完成后才执行提交动作。 Binlog中记录与提交顺序有关，而redolog并发写入，不同事务的记录在日志中会混在一起。 Binlog主要用于主从同步和数据库恢复，而redolog实现的是事务层面的重做。两者功能不同。  Mysql主从复制步骤  **在主库上把数据更改记录到二进制日志binlog中。**每次准备提交事务完成数据更新前，主库将数据更新的事件记录到二进制日志中。MySQL会按事务提交的顺序而非每条语句的执行顺序来记录二进制日志，在记录二进制日志后，主库会告诉存储引擎可以提交事务了。 **备库将主库的日志复制到自己的中继日志中。**备库首先会启动一个工作的 IO线程，IO线程跟主库建立一个普通的客户端连接，然后在主库上启动一个特殊的二进制转储线程，这个线程会读取主库上二进制日志中的事件。它不会对事件进行轮询。如果该线程追赶上了主库将进入睡眠状态，直到主库发送信号量通知其有新的事件产生时才会被唤醒，备库IO 线程会将接收到的事件记录到中继日志中。 **备库读取中继日志中的事件，在备库数据中重放。**当 SQL 线程追赶上 IO线程时，中继日志通常已经在系统缓存中，所以中继日志的开销很低。SQL线程执行的时间也可以通过配置选项来决定是否写入其自己的二进制日志中。  SQL常见语法 SQL语法教程\n其它 Spring Spring使用技术   控制反转/依赖注入（IoC）:通常情况下，由调用者来创建被调用者的实例。但在spring里创建被调用者的工作不再由调用者来完成，因此控制反转（IoC）；创建被调用者实例的工作通常由spring容器来完成，然后注入调用者，因此也被称为依赖注入（DI）。\n 优点：由于对象在XML中定义，所以可以在程序运行中更换调用类。实现热插拔 缺点：降低运行效率，不易改名    面向切面编程（AOP）: 将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。\n面向切面编程（AOP）就是对软件系统不同关注点的分离，开发者通过拦截方法调用并在方法调用前后添加辅助代码。利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多了类的公共行为封装到一个可重用的模块，并将其命名为“Aspect”，即切面。\n  Spring事务 Spring不会直接管理事务，而是提供了多种事务管理器。将事务管理委托给其它框架来实现。\n事务管理器PlatformTransactionManager接口如下：\n Public interface PlatformTransactionManager()…{ // Return a currently active transaction or create a new one, according to the specified propagation behavior（根据指定的传播行为，返回当前活动的事务或创建一个新事务。） TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; // Commit the given transaction, with regard to its status（使用事务目前的状态提交事务） Void commit(TransactionStatus status) throws TransactionException; // Perform a rollback of the given transaction（对执行的事务进行回滚） Void rollback(TransactionStatus status) throws TransactionException; }  （Void类型不能实例化，也没有可赋值的实例，只能置其为null）\nSpring事务管理接口包括：\n  PlatformTransactionManager： （平台）事务管理器\n 这是spring为各个平台提供的事务管理器类，通过getTransaction方法得到事务对象。传入参数类型为TransactionDefinition。该参数类型为事务提供设定属性。    TransactionDefinition： 事务定义信息\n 生成的事务对象提供属性，包括：事务隔离级别、事务传播行为、事务超时时间、事务是否只读、回滚规则（哪些事务会导致回滚）    TransactionStatus： 事务运行状态\n 可以用来获取事务当前的状态，包括是否为新事物，是否有恢复点，是否只回滚，是否已经完成    可能是最漂亮的Spring事务管理详解\nSpring初始化流程  初始化环境 加载配置文件 实例化bean 调用bean显示信息  Redis Redis基本特点：远程、基于内存、非关系型数据库、主从同步（从主服务器上向其它服务器同步）\nRedis应用场景：数据缓存、队列、数据存储、分布式锁、消息系统等\nRedis常见问题\nRedis客户端调用过程 Redis使用了单线程架构和IO多路复用模型来实现高性能的内存数据库服务。\n每次客户端调用都经历了发送命令、执行命令、返回结果三个过程。因为 Redis是单线程处理命令的，所以一条命令从客户端到达服务器不会立即执行，所有命令都会进入一个队列中，然后逐个被执行。客户端的执行顺序可能不确定，但是可以确定不会有两条命令被同时执行，不存在并发问题。\nRedis数据类型 Redis数据类型底层实现\nRedis数据结构简介\n  String：动态字节数组，可修改，内部实现类似于ArrayList（Simple dynamic string）\n  List：使用双向链表结构进行存储。首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成linkedlist（双端链表）。\n  Set：内部也使用hash结构，所有的value都指向同一个内部值。\n  Hash：使用二维结构，第一维是数组，第二维是链表。除扩容外还实现了缩容，区别于java hashmap，当链表长度过长时，hash中链表结构并不会调整为红黑树。此外，也采用了渐进式rehash来避免迁移时的cpu繁忙。即同时持有两个hash表，每次进行curd操作时，将操作数据写入到新表中。\n  Sort Set：可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。\n内部实现使用了hash和跳跃列表。hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。跳跃列表的目的在于给元素value排序，根据score的范围获取元素列表。因为跳跃表操作时间复杂度与平衡树大致相等，且维护操作要比平衡树简明，所以这里采用了跳跃表。\n  Redis发布（pub）与订阅（sub） SUBSCRIBE、UNSUBSCRIBE和PUBLISH三个命令实现了发布与订阅信息泛型（Publish/Subscribe messaging paradigm）， 在这个实现中，发送者（发送信息的客户端）不是将信息直接发送给特定的接收者（接收信息的客户端），而是将信息发送给频道（channel），然后由频道将信息转发给所有对这个频道感兴趣的订阅者。\n分布式锁 程序员小黑讲redis分布式锁\n  数据库使用for update实现对数据库锁的互斥访问\n  Redis setnx语句实现分布式锁，需要保证：\n Set设置锁指令和expire设置超时指令需要做为原子操作执行 将线程id做为锁的键值val传入，判断锁的拥有者 释放锁时，判断和释放锁需要做为一个原子操作执行（使用LUA） 需要给锁添加守护线程，当访问线程正常运行但锁时间到达时，守护线程给锁延时20s 分布式情况下，为了防止各服务器间锁不一致，需要使用redLock技术。    ZooKeeper实现分布式锁：\n 生成一个lock节点，所有需要抢锁的线程都会在这个节点下生成顺序子节点 按照各线程生成的节点编号来顺序获得锁，结束运行后当前线程删除节点 所有的线程都会向当前顺序位节点添加监视器，当节点被删除时，生成下一个节点的线程获得锁开始运行    Redis持久化 Redis持久化原理\n  RDB：在 指定时间间隔内对数据进行快照存储\n Redis之前版本都是单线程运行，为了存储redis快照，会调用fork函数产生子进程，使用子进程来对快照持久化进行处理。同时使用COW机制（父子进程均只读时，内存页正常；当有写时，触发中断复制当前页）来分享数据段页面。即复制一份待保存页面，用于持久化。但因为每次运行都要创建子线程，属于重量级操作，执行成本过高。 RDB是一个紧凑压缩的二进制文件，是redis在某个时间点上的数据快照。Redis加载RDB恢复数据远远快于AOF的方式。    AOF：记录每次对服务器写的操作，当服务器重启时会重新执行这些命令来恢复数据。\n 程序写AOF文件时，先写入一个内存缓冲区，每隔1s左右将缓冲区刷到磁盘。当AOF文件过大时，需要定期对AOF文件进行重写来达到压缩的目的。 Redis优先从AOF中恢复数据，没有再从RDB中恢复。    Redis主从同步 Redis主从同步主要分为两个步骤：同步（同步主从服务器数据库状态）和命令传播（同步完成后，从服务器需要重新执行主服务器执行的写命令）\n 同步：从服务器向主服务器发送同步请求，主服务器生成rdb文件发还给从服务器。并缓冲从当时刻开始的写命令。 命令传播：从服务器重新执行主服务器缓冲区命令，使服务器状态保持一致。（主从服务器保存当前状态下的缓冲命令偏移号，就可以知道从服务器需要从哪里开始同步命令） 反复执行命令传播，就可以保证主从同步。  Redis存在问题  缓存雪崩：由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力。解决方案：加锁、设置缓存标记及时更新数据（脏读）、设置不同缓存失效时间、二级缓存 缓存穿透：指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。解决方案：采用布隆过滤器、短时间内缓存保存空结果 缓存预热：指系统上线前，提前将相关缓存数据直接加载到缓存系统中。 缓存降级：延迟？  Redis过期淘汰策略 Redis的过期策略及内存淘汰机制\nRedis集群模式 你了解 Redis 的三种集群模式吗？\nRedis支持三种集群方案\n 主从复制模式：读写分离。主从初连接时进行全量同步，同步结束后对每条命令进行增量同步。 哨兵模式：可自动恢复的主从复制模式，使用哨兵进程监督主服务器是否下线，若下线则使用订阅模式，令所有被哨兵模式监控的从服务器切换主机。 Cluster模式 ：引入hash slot，每个key通过CRC16校验后对16384来确定负责的节点。同时也引入主从复制模式。Cluster模式可以支持分布式存储，减少内存消耗。  一致性Hash算法 为了提高缓存命中率，分布式系统中经常会将客户端通过hash与服务器绑定。为了保证服务器数量发生增加或者减小时，客户端仍能访问到对应的服务器。可以使用一致性Hash算法。\n什么是一致性hash算法\n即将hash后将服务器和客户端均映射到0-2^32-1的地址中，客户端会访问顺时针方向最近的服务器。\n当服务器数量过少时，为了防止服务器负载不均，可以在环中加入虚拟节点。\nMyBatis MyBatis入门看这一篇就够了\nMyBatis是ORM（Object Relational Mapping）的一种实现框架，是对JDBC的一种封装。\nMyBatis工作流程 Mybatis实现CURD操作\n 创建Mybatis配置文件，配置数据库相关的登录信息 配置对象类与表的映射关系 编写标签，对应标签id和需要调用的sql语句 在程序中连接sqlsession 调用sqlsession方法curd数据库（mybatis调用方法后需要commit）  MyBatis实现动态SQL 动态SQL即自动拼接SQL语句，在映射配置文件中使用标签生成SQL语句。\nMyBatis核心组件  SqlSessionFactoryBuilder：根据配置来生成SqlSessionFactory 主要需要在XML中配置数据库类型，URL，用户名和密码等 SqlSessionFactory：采用工厂模式生成SqlSession SqlSession：可以发送SQL语句返回结果。使用factory.openSession()方法构建，有commit/rollback/close等方法 SQL Mapper：由java接口和xml文件构成，给出sql语句和id的映射规则后可以调用sql并返回结果  MyBatis常用标签 MyBatis常用标签\n  定义sql语句\n Select（查询）、insert（插入）、delete（删除）、update（更新） ResultMap（建立resultset查询结果和java类属性的映射关系）    动态sql\n If（根据test确定是否加入text）、foreach（迭代加入sql）、choose（类switch）、where（更好地控制where选择）、set（更好控制update时地插入）    ${}和#{}区别  #{}填入SQL语句时可能会加入引号；${}则不会。 #类似于JDBC中的PreparedStatement（创建SQL查询时可以在语句中加？再依次传入参数替换），会先处理为?，后才会代入参数；${}则只是简单替换。 能使用#{}的地方尽可能使用，可能有效防止SQL注入。  Zookeeper 原创ZooKeeper入门实战教程（一）-介绍与核心概念\nZookeeper节点 Zookeeper通常用于作为分布式系统的分布式协同服务。主要使用共享存储来做分布式系统的协调。即使用数据节点znode来保存信息。Zookeeper数据节点根节点上包括4个子节点。分别为：\n Master：存储主节点信息 Workers：子节点下存储各个从节点的数据 Tasks：子节点下存储任务数据 Assign：子节点下存储各个从节点的任务集合  节点分为持久节点和临时节点：持久节点必须手动delete删除；临时节点在其创建者失联后关闭。\n有序节点：被声明为有序节点的节点在分配时会给予一个唯一的单调递增的证书。\nZookeeper中采用通知的机制监测znode变化。客户端可以在特定znode设置观察点，当znode发生变化即会触发通知，观察点触发一次后即会失效。\nZookeeper使用版本号来控制多客户端同步访问\nZookeeper角色  Leader：负责实际工作，及维护与其它节点的心跳。（所有的写操作必须要通过Leader 完成再由 Leader 将写操作广播给其它服务器。 只要有超过半数节点（不包括observeer 节点） 写入成功，该写请求就会被提交） Follower：响应leader心跳，follower可处理读请求，转交Leader写请求，并对写请求投票。 Observer：响应leader心跳，follower可处理读请求，转交Leader写请求。  Zookeeper事务编号 ZAB （ ZooKeeper Atomic Broadcast , ZooKeeper 原子消息广播协议） 协议的事务编号Zxid设计中， Zxid 是一个 64 位的数字，其中低 32 位是一个简单的单调递增的计数器，针对客户端每一个事务请求，计数器加 1；而高 32 位则代表 Leader 周期 epoch的编号， 每个当选产生一个新的 Leader 服务器，就会从这个 Leader 服务器上取出其本地日志中最大事务的 ZXID，并从中读取epoch 值，然后加1，以此作为新的 epoch，并将低 32 位从 0 开始计数。\n高32位用来保证新leader选出后，旧leader的命令不会再起作用。\nZab 协议有两种模式：恢复模式（选主）、广播模式（同步）\n分布式 分布式事务 分布式事务，这一篇就够了\n常用分布式系统解决方案\n分布式事务指事务的参与者、支持事务的服务器、资源管理器分别位于不同的分布式系统的不同节点上。本质上，分布式事务就是为了保证不同数据库中的数据一致性。分为三种一致性：强一致性（在任意时刻，所有节点中的数据是一样的）、弱一致性（数据更新后，后续访问只能访问到部分甚至全部访问不到）、最终一致性（保证在一段时间后，节点的数据最终会达到一致状态）\n  CAP原则：分布式系统中，一致性、可用性、分区容错性，只能同时满足两个。\n 一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本） 可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性） 分区容错性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C 和 A 之间做出选择。    BASE （Basically Available Soft State Eventual Consistency）理论：即分布式系统中即使无法保证强一致性，也应该采用适合的方式保证最终一致性。BASE 理论本质上是对 CAP 理论的延伸，是对 CAP 中 AP 方案的一个补充。\n BA：Basically Available 基本可用，分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。 S：Soft State 软状态，允许系统存在中间状态，而该中间状态不会影响系统整体可用性。 E：Consistency 最终一致性，系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。    柔性事务：分布式场景下基于BASE理论实现的事务解决方案。\n  分布式事务解决方案\n 全局事务（DTP模型） 基于可靠消息服务的分布式事务 最大努力通知（定期校对） TCC（两阶段型、补偿型） （txc待补充标记）    简历   相机采集图片：\n 使用被动获取图片方式，将图片保存入带有扫描位置的指定文件夹中，将图片名添加入发送队列，由线程发送 相机参数调节：标定，曝光，红黄蓝    服务器接收和处理\n  Javalin，httpclient每个书架间结束相机采集后，往发送队列ConcurrentLinkedQueue最后添加end。当服务器端设置文件监听事件，当收到end文件后开始调用图片处理程序。传递失败反复重传\n 图片拼接 文本检测，书脊分割    废弃机制：当遇障返回时，会发送failure放弃当次采集图片。放到data，生成result。维护hashset，记录废弃文件夹，全部去掉。\n  结束扫描后，机器人每30s向服务器请求结果，如果result文件夹下面有end文件，即生成结束，返回结果\n    新增错架报表模块\n 根据图书馆提供数据库及机器人扫描结果维护本地数据库，使用MyBatis（txc待补充标记），jxl。扫描后使用jxl生成excel报表发送到运维人员邮箱    改进和维护原盘点程序\n  改进rfid识别算法\n 改进错架识别算法，引入更多特征，采集数据集，使用word2vec和tensorflow计算 对不定长小格子改进识别方案，求变化最剧烈的部分。（视觉方案，RFID方案）      CV部分处理\n 图片拼接：求匹配点，图片配准，图片拼接并平滑过渡部分 文本检测：修改mobilenet主干网络，引入混合精度训练，加入sin/cos预测，调参 书脊分割：LSD，状态dp，文本域区域扩张    Springboot Git/lombok/log4j/\n待解决问题 ZGC、redis集群模式\n","description":"","tags":null,"title":"Java面试笔记","uri":"/it/java%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/"}]
